 ###### 1. **C++和C的不同以及对面向对象的了解**

（1）首先C语言是面向过程的程序设计，它的主要核心为：数据结构和算法，并且C语言是更接近底层的语言，所以它更高效。

（2）C++语言是面向对象的程序设计，它首要考虑的是如何构造一个对象模型，让这个模型配合对应的问题，最后通过这个模型获取对象状态信息以获得到输出。

（3）C++比C语言的增强点：

- 命名空间
- 变量检测增强
```
int g_var;
int g_var = 200;
int main(int argc, char* argv[]) {
	printf("g_var = %d\n", g_var);
	return 0;
}
```
在C语言中，输出正常：200
在C++中，运行出错，变量重定义。
- struct 加强：C 语言 struct 定义了一组变量的集合，C 编译器不认为这是一种新类型；C++ 编译器中的 struct 是一个新类型的定义声明。
```
struct Student
{
	char name[100];
	int age;
};
int main(int argc, char* argv[]) {
	Student s1 = {"wang", 1};
	// C语言中必须加上 struct 关键字:
	// struct Student s1 = {"wang", 1};
	// struct Student s1 = {"wang2", 2};
	Student s2 = {"wang2", 2};
	return 0;
}
```
（4）面向对象：==把数据和对数据的操作方法放在一起==，做成一个相互依靠的整体，称之为对象，对同类对象抽象出共同特性，类中大多数数据只能用本类的方法进行处理。
（5）面向对象的三大特性：封装、继承、多态
- 封装：将一类事物的属性和行为抽象成一个类，使属性私有化，行为公开化，提高数据的隐蔽性，复用性更高。
- 继承：进一步将属性和行为抽象为一个父类，而每一个子类拥有父类的行为和属性，也有自己的行为和属性。
- 多态：接口复用。
- 
###### 2. **C++是不是类型安全的？**

- 不是。两个不同类型的指针之间可以强制转换（使用reinterpret_cast）。

###### 3. **面向对象的三大特性**

- 封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的 private 和 public；

- 继承使得子类可以复用父类的成员和方法，实现了代码重用；

- 多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。

###### 4. **this 指针**

- this 指针是存在于类成员函数中，指向类对象的指针。this 是一个关键字，同时是一个常量指针。

###### 5. **定义和声明的区别**

- 声明是告诉编译器变量的类型和名字，不会为变量分配空间。
- 定义是对这个变量进行内存分配和初始化。需要分配内存空间，同一个变量可以声明多次，但只能定义一次。

###### 6. **局部变量能否和全局变量重名**

- 能，局部变量会屏蔽全局变量，若要在重名的情况下使用全局变量，需要加上作用域“ :: ”。

- 局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部量，而不会用到全局变量。对于有些编辑器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义同一个同名局部变量，而那个局部变量的作用域就在那个循环体内。

###### 7. **如何引用一个已经定义过的全局变量？**

- 可以用引用头文件的方式，也可以用 extern 关键字，如果用引用头文件方式来用某个在同文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错（编译时发现未声明该变量）。若你用 extern 方式引用全局变量，假定你犯了同样的错误，那么在编译期间不会报错，而是会在链接期间报错（在链接时会找你定义过的 extern 同名变量，而不是在编译期间找，所以若你把变量名写错了，那么会在链接期间报错）。

###### 8. **全局变量可不可以定义在可被多个.C文件包含的头文件中？为什么？**

- 可以，在不同的 C 文件中以 static 形式来声明同名全局变量（因为静态变量会被存放在全局数据区，并且在程序声明周期内都不会被释放）。

- 可以在不同的C 文件中声明同名的全局变量，前提是其中只能有一个 C 文件中对此变量赋初值，此时链接不会出错。

###### 9. **指针与引用的区别？**

- 指针：一个变量，存储的内容为一个地址；引用：给一个已有对象起的别名；

- 指针是一个实体，需要分配内存空间；引用只是变量的别名，不需要分配内存空间；

- 可以有多级指针，但是不能有多级引用。

- 自增运算结果不一样。

- 指针是间接访问（指针用自己的地址保存变量的地址，然后通过对地址取值来进行间接访问），引用是变量的别名，与变量名一样直接指向变量的地址，所以可以直接访问变量。

- 指针可以不初始化，但是引用必须初始化。

###### 10. **指针与数组的区别？**

- 含以上的区别：数组对应着一块内存，而指针是指向一块内存。数组的地址和空间大小在生命周期内不会发生改变，内容可能会发生改变，而指针的内存大小可以随时发生改变，但是当指针指向常量字符串时，它的内容不可更改。

-  计算容量的区别：用 sizeof 计算出数据的元素个数，无法计算指针所指向内存的大小

- 数组名类似指针常量，指针是指针变量

- 对数组用 & 和对指针 & 的意义不同，此时数组名不在当成指向一个元素的常量指针来使用

###### 11. **将 "引用" 作为函数参数有哪些特点**

- 传递引用给函数与传递指针的效果是一样的。这时，==被调函数的形参==就==成为==原来==主调函数==中的==实参变量或对象的一个别名==来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

- 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量时实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比一般传参的效率和所占空间都好。

- 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用 “ * ” 运算符进行运算，这很容易导致错误的产生以及代码的阅读性变差；另一方面，在主调函数的调用点处，必须使用变量的地址作为实参。而引用更容易使用，更加清晰。

###### 12. **如何让 main 函数之前执行函数？**

- C++ 中在 main 函数之前定义一个全局对象，调用构造函数。

###### 13. **在什么时候需要使用 “常引用” ？**

- 如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被篡改，就应使用常引用。常引用的声明方式：‘ const 类型标识符 & 引用名 = 目标变量名；’

```
int a;
const int&ra = a;
ra = 1; // 错误 ra 是const int& 类型，其指向的值为常量，不可更改
a = 1; // 正确
```

```
string foo();
void bar(string&s); // 那么下面的表达式将是非法的: bar(foo());
bar(foo());
bar("hello world");
```
- 原因在于foo( )和 “hello world” 串都会产生一个临时对象，而在 C++ 中，这些临时对象都是 const 类型的。因此上面的表达式就是试图将一个 const 类型的对象转换为非 const 类型，这是非法的。

- 引用型参数应该在能被定义为 const 的情况下，尽量定义为 const 。

###### 14. **.h 头文件中的 ifndef/define/endif 的作用？**

- 防止该头文件被重复引用。

###### 15. **typedef 和 define 区别**

- l#define 是预处理命令，在预处理是执行简单的替换，不做正确性的检查。
- typedef 是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名

###### 16. **结构与联合有什么区别？**

- 结构和联合都是由多个不同的数据类型成员组成，但在任何同一时刻，联合中只存放了一个被选中的成员（所有成员共用一块地址空间）， 而结构的所有成员都存在（不同成员的存放地址不同）。
- 对于联合的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了，而对于结构体，不同成员的赋值是互不影响的。

###### 17. **l#include<file.h> 与 l#include "file.h" 的区别**

- 前者是从标准库文件的路径寻找和引用 file.h，而后者是从当前工作路径搜寻并引用 file.h。

###### 18. **在C++程序中调用被 C 编译器编译后的函数，为什么要加 extern "C"？**

- 首先，作为 extern 是 C/C++ 语言中表明函数和全局变量作用范围（可见性） 的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其他模块中使用。
- 通常，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字 extern 声明。例如，如果模块 B 欲引用该模块 A 中定义的全局变量和函数时，只需包含模块 A 的头文件即可。这样，模块  B 中调用模块 A 中的函数时，在编译阶段，模块 B 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块 A 编译生成的目标代码中找到此函数。
- extern “C” 是连接申明(linkage declaration)，被 extern "C" 修饰的变量和函数是按照 C 语言方式编译和连接的，接下来是 C++ 中对类似 C 的函数是怎样编译的：
  -  作为一种面向对象的语言，C++ 支持函数重载，而过程式语言 C 则不支持。函数被 C++ 编译后再符号库中的名字与 C 语言的不同。例如假设某个函数原型为：
  ```
  void foo(int x, int y)；
  ```
  - 该函数被 C 编译器编译后再符号库中的名字为_foo，而 C++ 编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字成为 “mangled name”）。
  - l_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息，C++ 就是靠这种机制来实现函数重载的。例如，在 C++ 中，函数 void foo(int x, int y) 与 void foo(int x, float y)编译生成的符号是不相同的，后者为_foo_int_float。
  - 同样的，C++ 中的变量除支持局部变量外，还支持成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以 “.” 来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与程序中同名的全局变量名字也不同。

###### 19. **struct 和 class 的区别**

- struct 的成员默认是公有的，而类的成员默认是私有的。struct 和 class 在其他方面上的功能相当。

###### 20. **BOOL , int , float 指针类型的变量 a 与 "零" 的比较语句**

```
BOOL : if ( !a ) or if (a)
int : if ( a == 0 )
float : const EXPRESSION EXP = 0.000001 if (a < EXP && a > -EXP)
pointer : if ( a != NULL) or if(a == NULL)
```

###### 21. **写一个 “标准” 宏 MIN ，这个宏输入两个参数并返回较小的一个。**

```
#define MIN(A,B) ((A) <= (B) ? (A) : (B))
```
- 参数用括号括起来；
- 考察能否合理运用条件运算符；

###### 22. **const 关键字作用**

- const 修饰全局变量
- const 修饰局部变量
- const 修饰指针，const int*
- const 修饰指针指向的对象，int* const
- const 修饰引用做形参 （确保内容不会被改变且节省空间）
- const 修饰成员变量，必须在构造函数列表中初始化
- const 修饰成员函数，说明该函数不应该修饰非静态成员，但是这并不是十分可靠的，指针所指向的非成员对象值可能会被改变

###### 23. **const、define、inline 的区别**

- 本质：define 只是字符串替换，const 参与编译运行
- define 不会做类型检查，const 拥有类型，会执行相应的类型检查
- const 内存效率更高，编译器通常将 ==const 变量== (const 修饰可读变量在 c 语言中可以通过指针进行修改，c++ 中则将 const 优化为不可修改) ==保存在符号表中==，而==不会分配存储空间==，这使得它成为一个编译期间的常量，==没有存储和读取的操作==。
- 本质：define 只是字符串替换，inline 由编译器控制
- 内联函数在编译时展开，而宏是由预处理器对宏进行展开
- 内联函数会检查参数类型，宏定义不检查函数参数，所以内联函数更安全。
- 宏不是函数，而 inline 函数是函数。
- 宏在定义时要小心处理宏函数（一般情况是吧参数用括弧括起来）。

###### 24. **不用临时变量实现两个变量的交换**

```
#include <iostream>
using namespace std;

void Switch(int *p1, int *p2){
	*p1 = *p1 + *p2;
	*p2 = *p1 - *p2;
	*p1 = *p1 - *p2;
}

void Xor(int *p1, int *p2) {
	*p1 = *p1 ^ *p2;
	*p2 = *p1 ^ *p2;
	*p1 = *p1 ^ *p2;
}

int main() {
int a = 1, b = 2;
int *p1 = &a;
int *p2 = &b;
cout << "*p1 = " << *p1 << endl;
cout << "*p2 = " << *p2 << endl;

Switch(p1, p2);
cout << "*p1 = " << *p1 << endl;
cout << "*p2 = " << *p2 << endl;

Xor(p1, p2);
cout << "*p1 = " << *p1 << endl;
cout << "*p2 = " << *p2 << endl;

system("pause");
return 0;
}
```
方法一缺陷：相加求和可能存在数值溢出的情况。

###### 25. ** C/C++ 内存管理方式，内存分配**

- 内存分配方式：在 C++ 中内存分为 5 个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区。
- 栈：在执行程序过程中，局部作用域出现的一些局部变量可以在栈上创建，等脱离该作用域创建的内存被释放。栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压出栈都有专门的指令执行，这就决定了栈的效率比较高。
- 堆：用于程序内存动态分配，用 c/c++ 中的 malloc/new 分配，delete/free 释放
- 堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小堆空间因为会有频繁的分配释放操作，会产生内存碎片，存储局部变量。
- 自由存储区：它是 C++ 基于 new 操作符的一个概念，凡是通过 new 操作符申请的内存即为自由存储区
- 全局/静态存储区：这块内存在程序编译期间已经分配好，在程序整个运行阶段一直存在。全局变量和静态变量
- 常量存储区：特殊的一块内存，里面存放的是常量，不允许修改。

###### 26. **一个 C++ 源文件从文本到可执行文件经历的过程**

- 预处理：对所有的 define 进行宏替换；处理所有的条件编译 (#idef) 等；处理 (#include)指令；删除注释等；
- 编译：将预处理后的文件进行词法分析，语法分析，语义分析以及优化相应的汇编文件
- 汇编：将汇编文件转换成机器能执行的代码
- 链接：包括地址和空间分配，符号决议和重定位

###### 27. **堆栈溢出一般是由什么原因导致的？**

- 没有回收垃圾资源
- 层次太深的递归调用

###### 28. **C++函数栈空间最大值**

- 默认是 1M，不过可以调整

###### 29. **Heap 与 Stack 的差别？**

- Heap 是堆，Stack 是栈。
- Stack 的空间由系统自动分配/释放，Heap 上的空间手动分配/释放。
- Stack 空间有限，Heap 是很大的自由存储区，malloc 函数分配的内存空间即在堆上。

###### 30. **关键字 const 有什么含义？**

- const 意味着 “只读” ，修饰变量。
```
#include <stdio.h>
#include <stdlib.h>
int main() {
const int a = 1;
int *p = &a;
*p = 2;
printf("%d", a); // 由于是.c文件，输出结果是 2
return 0;
}
```

###### 31. **下面声明是什么意思？**

```
const int a;
int const a;
const int *a;
int * const a;
int const *a const;
```
- 前两个作用相同，a 是一个常整形数；
- 第三个意味着 a 是一个指向常整数型的指针（整型数不可修改，但是指针可以改指向）
- 第四个意思 a 是一个指向整形数的常指针（指针指向的整数是可以修改的，但是指针不能改变指向）
- 最后一个意味着 a 是一个指向常整形数的常指针（指针同其指向，都是不可修改的）

###### 32. **关键字 extern**

- 修饰变量：变量声明，表明变量在此处引用，在其他源文件中定义。
- 修饰函数：表明函数在其他源文件中定义。
- extern “C”：编译器用 C 的命名规范去编译函数，链接器用 C 的命名规范进行链接。因为 C++ 支持函数重载，而C不支持。
```
// c++代码
extern "C"
{
	void C() {
	
	}
}
```

###### 33. **内存泄漏、野指针**

- 内存泄漏：动态申请的内存空间没有被正常释放，但也不能继续被使用的情况。
- 野指针：指向被释放的内存或者访问受限的指针，造成的原因：
	- 指针未被初始化
	- 被释放的指针没有被置 NULL
	- 指针越界操作
	- 解决内存泄漏的办法：使用智能指针

###### 34. **计算下面几个类的大小：**
```
class A {};
int main() {
cout << sizeof(A) << endl; // 输出 1;
A a;
cout << sizeof(a) << endl; // 输出 1;
return 0;
}
```
- 空类的大小是 1，在 C++ 中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为 0 了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。
- 空类的实例大小就是类的大小，所以 sizeof(a) = 1 字节，如果 a 是指针，则 sizeof(a) 就是指针的大小，即 4 字节。
```
class A {
	virtual work(){}
};
int main() {
	cout << sizeof(A) << endl; // 输出 4(32位机器) / 8(64位机器);
	A a;
	cout << sizeof(a) << endl; // 输出 4(32位机器) / 8(64位机器);
	return 0;
}
```
- 因为有虚函数的类对象中都有一个虚函数表指针_vptr，其大小是 4 字节。
```
class A {
	static int a;
};
int main() {
	cout << sizeof(A) << endl; // 输出 1;
	A a;
	cout << sizeof(a) << endl; // 输出 1;
	return 0;
}
```
- 静态成员存放在静态存储区，不占用类的大小，普通函数也不占用类的大小，静态成员变量 a 不占用类的大小，所以类的大小就是 b 变量的大小，即 4 字节。
```
class A { int a; };
int main() {
	cout << sizeof(A) << endl; // input 4;
	A a;
	cout << sizeof(a) << endl; // input 4;
	return 0;
}

class A {static int a; int b; };
int main() {
	cout << sizeof(A) << endl; // input 4;
	A a;
	cout << sizeof(a) << endl; // input 4;
	return 0;
}
```
###### 35. **static**

- 局部静态变量：static 局部变量和普通局部变量有什么区别？
	static 局部变量只被初始化了一次，下一次依据上一次结果值；程序的局部变量存在于 (堆栈) 中，全局变量存在于 (静态区) 中，动态申请数据存在于 (堆) 中。
- 全局静态变量：static 全局变量与普通的全局变量有什么区别？
- 
	全局变量(外部变量)的说明之前再冠以 static 就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者再存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。

	从以上分析可以看出，把局部变量改为静态变量后是改变了它的存储方式，即改变了它的生存期。把全局变量改为静态变量后，改变的是它的作用域，限制了它的使用范围。static 全局变量与普通的全局变量有什么区别：static 全局变量只初始化一次，防止在其他文件单元中被引用；
	
- 静态成员函数：static 函数与普通函数有什么区别？
- static 函数与普通函数作用域不同，仅在本文件。只在当前源文件中使用的函数应该说明为内部函数(static)，内部函数应该在当前源文件中说明和定义。对于可在当前源文件以外使用的函数，应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件，static 函数与普通函数有什么区别：static 函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

###### 36. **malloc 的原理**
- 函数原型：void* malloc(size_t n)返回值类型为void*，为动态分配得到的内存，但大小是确定的，不允许越界使用。
- malloc 函数的实质体现在它有一个可以将可用内存块连接成一个空闲链表，当调用链表时，它沿着链表寻找一个大到刻意满足用户请求所需内存，将内存一分为二，将分配给用户那块内存传给用户，剩下的那块返回链表。

###### 37. **既然有了 malloc/free，C++ 中为什么还需要 new/delete 呢？**

- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 malloc/free 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 malloc/free。

###### 38. **delete 和 delete[]的区别**

- delete 只会调用一次析构函数，而 delete[] 会调用每个成员的析构函数
- 用 new 分配的内存用 delete 释放，用 new[] 分配的内存用 delete[] 释放

###### 39. **union 和 struct**

- 在存储信息时，struct 可以存储多个成员，而 union 每个成员会共享一个存储空间，只能存储最后一个成员。
- 在任何时刻，union 只存放被选中的那个成员，struct 每个成员都在
- 对 union 的不同成员赋值，将会对其他成员重写

###### 40. **strlen，strcpy 函数实现**

```
#include <iostream>
#include "test.h"
uisng namespace std;
// 将 src 字符串复制到 desc 中
char* mystrcpy(char* desc, const char* src) {
	if (desc == NULL || src == NULL) // 内存正常判断
	{
		return NULL;
	}
	char* str = desc;
	while ( (*str = *src) != '\0') // '\0' 字符串结束标志
	{
		str++;
		src++;
	}
	return desc;
}

// 将 src 字符串连接到 desc 中
char* mystrcat(char* desc, const char* src) {
	if (desc == NULL || src == NULL) {
		return NULL;
	}
	char* str = desc;
	while(*src++ != '\0'); // 找到字符串结尾
	src--;
	while((*desc++ = *src++) != '\0'); // 将源字符串添加到目的字符串
	return str;
}

// 将 src 字符串前 n 个字符复制到 desc 中
char* mystrncpy1(char* desc, const char* src, int n) {
	char* str = desc;
	// 缺少一步判断内存是否不足
	int m = 0;
	while (*str != '\0') {
		str++;
		m++;
	}
	if (desc == NULL || src == NULL || n>m) // 内存正常判断
	{
		return NULL;
	}

	while (n--) {
		*str++ = *src++;
	}
	return desc;
}

// 比较两个字符串大小
int mystrcmp(const char* str1, const char* str2) {
	while (*str1 && *str2 && *str1 == *str2) {
		str1++;
		str2++;
	}
	return *str1 - *str2;
}

// 求出字符串 str 长度
int mystrlength(const char* src) {
	if (src == NULL) {
		return 0;
	}

	int n = 0;
	while (*src++ != '\0') {
		n++;
	}
	return n;
}
```

###### 41. **memcpy,memset 内部函数实现**

- 如果发生了内存重叠 即 src = 1 2 3 4 5  des = 2 3 4 5 若要将des赋值为 1 2 3 4 则需从des尾部也是就 des[3] = src[3] 赋值起 直到 des[0] = src[0]。
- 还有判断是否重叠，若 src + count 大于des的首地址的时候，肯定是发生重叠了。即：src  des  1 2 3； count = 3；src + 3 > des；
```
#include<iostream>
using namespace std;
/*
	memcpy 函数用于资源内存（src指向的内存）拷贝到目标内存（desc指向的内存）; 拷贝个数 size
	用法 :: (1)可以拷贝任何类型的对象，因为函数的参数类型是void*，由于函数拷贝是一个字节一个字节拷贝，实际操作是将void*强制转换成了char*。这样才能保证每一次加一个指针。
*/

//实现，未考虑内存重叠情况
void* memcpy1(void* desc, const void* src, size_t size) {
	if (desc == NULL && src == NULL) {
		return NULL;
	}
	unsigned char* desc1 = (unsigned char*)desc; //将 void* 转换成 unsigned char* 类型
	unsigned char* src1 = (unsigned char*)src; // 同上
	while (size-- > 0) {
		*desc1++ = *src1++;
	}
	return desc;
}

//考虑内存重叠的情况
void* memcpy2(void* desc, const void* src, size_t size) {
	if(desc == NULL && src == NULL) {
		return NULL;
	}
	unsigned char* desc1 = (unsigned char*)desc;
	unsigned char* src1 = (unsigned char*)src;
	//当内存重叠时，从后往前赋值
	if(desc > src && desc1 < (src1 + size)) //内存发生重叠
	{
		for (int i = size - 1; i >= 0; i--) {
			*desc1++ = *src1++;
		}
	}
	else {
		for (int i = 0; i < size; i++) {
			*desc1++ = *src1++;
		}
	}
	retutn desc;
}

// memset 内部实现 memset(void* s,int ch,size_t n)
/* 将 s 所指向的某一块内存中的前 n 个字节的内容全部设置为 ch 指定的 ASCII 值，返回s */
void* memset1(void* ptr, int value, size_t n) {
	if (ptr == NULL && n < 0) {
		cout << "赋值出现错误" << endl;
		return;
	}
	char* s = (char*)ptr; // 定义一个指针来接 str; 辅助指针
	while (n--) {
		*s++ = (char)value;
	}
	return ptr;
}

// 下面就是根据源码而来的 memset 实现:

void* memset(void* dst, int val, size_t count) {
	void* ret = dst;
	while(count--) {
		*(char*)dst = (char)val;
		dst = (char*)dst + 1;
	}
	return ret;
}
```

###### 42. **C/C++ 内存管理方式，内存分配**

- 内存分配方式：在C++中内存分为 5 个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区。
- 栈：在执行程序过程中，局部作用域出现的一些局部变量可以再栈上创建，等脱离该作用域创建的内存被释放。栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
- 堆：用于程序内存动态分配，用 C/C++ 中的 new/malloc 分配，delete/free 释放。堆则是 C/C++ 函数库提供的，它的机制是很复杂的。
- 自由存储区：它是 C++ 基于 new 操作符的一个概念，凡是通过 new 操作符申请的内存即为自由存储区。
- 全局/静态存储区：这块内存在程序编译期间已经分配好，在程序整个运行阶段一直存在。全局变量和静态变量存放在这里。
- 常量存储区：特殊的一块内存，里面存放的是常量，不允许修改。

###### 43. **被 free 回收的内存是立即返还给操作系统吗？为什么**

- 不会返还给操作系统，被 free 回收的内存会首先被 ptmalloc 使用链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时 ptmalloc 也会尝试对小块内存进行合并，避免过多的内存碎片。

###### 44. **友元函数和友元类**

- 友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个普通函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。一个函数可以使多个类的友元函数，但是每个类中都要声明这个函数

```
#include <iostream>

using namespace std;

class A {
public:
	friend void set_show(int x, A &a); //该函数是友元函数的声明
private:
	int data;
};

void set_show(int x, A &a) //友元函数定义，为了访问类 A 中的成员
{
	a.data = x;
	cout << a.data << endl;
}
int main(void) {
	class A a;
	set_show(1, a);
	return 0;
}
```
- 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明
 ```
 #include<iostream>
 using namespace std;

 class A {
	 public:
		 friend class C; // 友元类声明
	 private:
		 int data;
 };

 class C  // 友元类定义，为了访问类 A 中的成员
 {
	 public:
		 void set_show(int x, A &a) {
			 a.data = x;
			 cout << a.data << endl;
		 }
 };

 int main(void) {
	 class A a;
	 class C c;
	 C.set_show(1, a);
	 return 0;
 }
 ```
- 使用友元类时要注意：
	- 友元类关系不能被继承
	- 友元关系是单向的，不具有交换性。若类 B 是类 A 的友元，类 A 不一定是类 B 的友元，要看在类中是否有相应的声明。
	- 友元关系不具有传递性。若类 B 是类 A 的友元，类 C 是 B 的友元，类 C 不一定是类 A 的友元，同样要看类中是否有相应的申明。

###### 45. **如何创建一个类，使得他只能在堆或者栈上创建？**

- 只能在堆上生成对象：将析构函数设置为私有。
	- 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能再栈上创建对象。
```
class A {
	~A() {
	
	}
public:
	A() {
	
	}

};
```
- 只能在栈上生成对象：将 new 和 delete 重载为私有。
	- 原因：在堆上生成对象，用 new 关键词操作，其过程分为两段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作符设置为私有，那么第一阶段就不能完成，就不能够在堆上创建对象。
```
class A {
	void* operator new (size_t a) {
	
	}
public:
	A() {
	
	}
	~A() {
	
	}
};
```

###### 46. **深拷贝和浅拷贝的区别**

- 浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。
- 深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。
- 深拷贝可以避免重复释放和写冲突。eg: 使用浅拷贝的对象进行释放后，对源对象的释放会导致内存泄漏或程序崩溃。

###### 47. **空类或空 struct 的 sizeof 是 1 **

- struct 和 class 在空的时候会自动加一个 char 或 int 变量进去。原因是当它们为空时，指向它们的指针将无法区分一个或多个同类的 struct/class。也就是说，在实例化时会导致指针错乱。
- 如果 class A 为空，那么对于数组 A a[10] 来说，a，a+1，a+9 实际上都是指向 a[0], (因为 a+n 实际上是 a + sizeof(class)*n) 那怎么区分 a[0] 和 a[9] 呢？这就出问题了。

###### 48. **静态多态和动态多态**

- 多态分为静态多态和动态多态。静态多态是通过重载和模版技术实现，在编译的时候确定。动态多态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

###### 49. **重写、重载与隐藏的区别**

- 重载的函数都是在一个作用域内（一个大括号内）。只有参数类型或者参数个数不同，重载不关心返回值的类型。
- 覆盖（重写）派生类中重新定义的函数，其函数名，返回值类型，参数列表都跟基类函数相同，并且基类函数前加了 virtual 关键字。
- 隐藏是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不关参数列表是否相同，基类函数都会被隐藏。有两种情况：(1) 参数列表不同，不管有无 virtual 关键字，都是隐藏； (2) 参数列表相同，但是无 virtual 关键字，也是隐藏。

###### 50. **静态链接与动态链接的区别**

- 静态链接
	- 所谓的静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。
- 动态链接
	- 所谓动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时链接的目的。优点是多个程序可以共享同一段代码，而不需要再磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。
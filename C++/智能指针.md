####  一、为什么会有智能指针  
因为普通指针存在的一些问题：
1. 访问失败：如果一块内存被多个指针指向，当其中任意一个指针将其释放后，其他指针不知道这块内存已经被释放，如果其他的指针访问这块被释放的内存，就会出现访问失败的情况。
2. 内存泄漏：当我们申请了一块内存空间后未释放，就会造成内存泄漏。
#### 二、智能指针是什么  
指针在构造的时候**分配内存**，当离开作用域的时候会**自动释放分配的内存**，从而减轻程序员手动管理内存繁杂的情况。

>所有权：C++ 里面的对象所有权的关系，指的是谁负责`delete`谁的关系。
>单一所有权：所有权拥有着有义务去释放或转移所有权，同一时刻只会有一个所有权拥有者。
>共享所有权：和使用裸指针一样，所有权的使用者不必释放内存，引用计数器会负责释放内存，同一时刻可以有多个所有权拥有者。
#### 三、智能指针的作用
1. 自动释放内存，防止程序员忘记delete造成内存泄漏。
2. 明确资源的所属权。
3. 更好的处理异常。

> 更好的处理异常，简单的来说就是当程序员在函数中申请了一块空间，并且在函数尾部将这块空间释放了，这没有问题，但是如果在这个函数未到达尾部时，就结束了函数，比如说异常终止情况，或是函数有多路出口的情况（这种比较少吧，毕竟多路出口一定会每条路都有delete的），这时函数结束了，内存空间没有被释放，就需要智能指针自动释放掉了。
#### 四、C++11 提供的智能指针
1. shared_ptr (共享所有权指针)：shared_ptr 是具有共享所有权语义的智能指针。每当共享指针的最后一个所有者被销毁时，关联对象都将被删除(或关联资源被清除)。
2. unique_ptr (独占所有权指针)：两个unique_ptr不能指向同一个对象，不能进行复制操作，只能进行移动操作(unique_ptr 必须直接初始化，因为其不可拷贝和赋值)。
3. weak_ptr (弱引用智能指针)：它指向一个shared_ptr所管理的内存资源，但是不会增加内存资源的引用计数。当所指向的内存资源被释放时，weak_ptr会自动变成空指针。是shared_ptr的一种补充，可以解决shared_ptr的循环引用问题，但是不能直接访问对象，需要先将其转换为shared_ptr。
> shared_ptr 循环引用的问题：当两个对象 A 和 B 互相持有对方的 shared_ptr 就会形成循环引用，在这种情况下，当程序结束，A 和 B 的引用计数都为1，导致它们不会被正确的释放，从而造成内存泄漏。
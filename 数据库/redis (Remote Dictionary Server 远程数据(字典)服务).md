redis是nosql式数据库，它与数据库存储方式不同，它解决了普通SQL数据库频繁IO磁盘导致服务器过载的问题。nosql数据库是用键值存储数据的，并且redis将数据存放在内存中，提高了服务器对数据读取的响应速度，但是比之SQL数据库的存储容器磁盘来说美中不足的是内存的价格太贵了，也就是用金钱来减轻负载，提升效率。

首先redis的工作原理是，当用户发送一条数据请求到数据库时，它会先将请求拦下来，看看在它的缓存中有没有该条数据，如果有的话就直接从内存中返回给用户，如果没有的话，就将请求交给SQL服务器，并且将SQL服务器返回的数据存放在内存中，方便用户下次进行同样请求时能及时反馈。

###### redis缓存穿透问题：
介绍完redis的工作原理后，接下来说redis缓存穿透问题，即是在用户向数据库请求一条不存在的数据时，由于该条数据不存在，所以缓存中没有，redis就将其交付给SQL服务器，但是SQL服务器中也没有该条数据，就导致缓存中不会更新，之后如果该用户反复请求不存在的数据，就会造成SQL服务器反复查询不存在的数据造成资源的浪费。这就是redis的缓存穿透问题。

解决方法：
1. 对用户请求参数进行检验，比如说如果合法参数都是15xxx这种以15开头的参数，而用户请求参数是以16开头的，那么就可以参数校验失败，将该请求拦截掉。
2. 若内存数据较少，可以直接将全部数据放入一个map中(呃类似废话，直接将SQL替代掉，也就是不用SQL参与，也就无法造成穿透问题，但是大型数据库的情况很难实现，小型数据库也用不太上redis吧。。)，当来请求时，直接在缓存中查找，若找不到该数据，则直接拒绝请求。
3. ==布隆过滤器==：它是通常用来解决redis缓存穿透问题的方法，布隆过滤器的本质其实就是类似set一样的运行机制，不同的是，布隆过滤器通过一个很长的二进制向量，再配合多个无偏hash函数(无偏hash函数是输入一个值时，它的返回值相同)来进行工作，在这个二进制向量中，存放已有的数据的名称，也就是它是否存在的那个id，假如说我用三个无偏函数来计算，那么就是先将这个数据的id分别传入三个无偏hash函数中，计算出三个值，然后再二进制向量中找到这三个值对应的位置，将它们置为1，这样存放完毕之后，当我下次要请求这个数据时，则会将数据id传入无偏hash函数中，计算三个值，当然这三个值是存在的，那么redis就可以向服务器请求数据。
==注意==：
- 布隆过滤器若通过，则表示该数据可能存在；若布隆过滤器不通过，则表示该数据一定不存在（hash冲突）。
- 布隆过滤器只能加入不能删除。
- 布隆过滤器的同步问题，由于是异步同步，如果在用户注册场景中由于网络波动同步失败了，这时用户再传请求过来，会被误判拦截，这时候布隆过滤器就帮了倒忙。

![[布隆过滤器示例图.png]]
###### redis缓存击穿问题：
缓存击穿的境况是当大量用户同时请求同一资源时，缓存突然失效(key过期)，这样就导致同一时间大量的请求全部堆到数据库上，可能导致数据库直接挂掉，这就是redis的缓存击穿。

解决方法：
- 加锁解决
- key自动续期

###### redis缓存雪崩问题：
缓存雪崩问题是缓存击穿问题的升级版，击穿指一个热门key失效，而雪崩指多个热门key失效。还有一种可能是缓存服务器宕机了，雪崩就是指大量多种访问同时访问数据库，而导致数据库负载过大甚至直接挂掉。

解决方法：
- 可以将key过期时长设置为不同，例如加上一个随机数，不让它们同时失效。
- 缓存服务器宕机的情况，可以让redis使用哨兵模式或者集群模式，避免单节点故障导致整个服务不可用。
注意：==哨兵模式==是当master服务下线时，自动将该服务下的某个slave服务升级为master服务替代已下线的master服务继续处理请求。